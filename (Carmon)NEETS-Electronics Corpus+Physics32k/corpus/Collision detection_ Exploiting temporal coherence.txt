In many applications, the configuration of physical bodies from one time step to the next changes very little. Many of the objects may not move at all. Algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step, resulting in faster completion of the calculation.
At the coarse level of collision detection, the objective is to find pairs of objects which might potentially intersect. Those pairs will require further analysis. An early high performance algorithm for this was developed by Ming C. Lin at the University of California, Berkeley [1], who suggested using axis-aligned bounding boxes for all n bodies in the scene.
Each box is represented by the product of three intervals (i.e., a box would be




I

1


×

I

2


×

I

3


=
[

a

1


,

b

1


]
×
[

a

2


,

b

2


]
×
[

a

3


,

b

3


]


{\displaystyle I_{1}\times I_{2}\times I_{3}=[a_{1},b_{1}]\times [a_{2},b_{2}]\times [a_{3},b_{3}]}
.) A common algorithm for collision detection of bounding boxes is sweep and prune. We observe that two such boxes,




I

1


×

I

2


×

I

3




{\displaystyle I_{1}\times I_{2}\times I_{3}}
and




J

1


×

J

2


×

J

3




{\displaystyle J_{1}\times J_{2}\times J_{3}}
intersect if, and only if,




I

1




{\displaystyle I_{1}}
intersects




J

1




{\displaystyle J_{1}}
,




I

2




{\displaystyle I_{2}}
intersects




J

2




{\displaystyle J_{2}}
and




I

3




{\displaystyle I_{3}}
intersects




J

3




{\displaystyle J_{3}}
. We suppose that, from one time step to the next,




I

k




{\displaystyle I_{k}}
and




J

k




{\displaystyle J_{k}}
intersect, then it is very likely that at the next time step, they will still intersect. Likewise, if they did not intersect in the previous time step, then they are very likely to continue not to.
So we reduce the problem to that of tracking, from frame to frame, which intervals do intersect. We have three lists of intervals (one for each axis) and all lists are the same length (since each list has length



n


{\displaystyle n}
, the number of bounding boxes.) In each list, each interval is allowed to intersect all other intervals in the list. So for each list, we will have an



n
×
n


{\displaystyle n\times n}
matrix



M
=
(

m

i
j


)


{\displaystyle M=(m_{ij})}
of zeroes and ones:




m

i
j




{\displaystyle m_{ij}}
is 1 if intervals



i


{\displaystyle i}
and



j


{\displaystyle j}
intersect, and 0 if they do not intersect.
By our assumption, the matrix



M


{\displaystyle M}
associated to a list of intervals will remain essentially unchanged from one time step to the next. To exploit this, the list of intervals is actually maintained as a list of labeled endpoints. Each element of the list has the coordinate of an endpoint of an interval, as well as a unique integer identifying that interval. Then, we sort the list by coordinates, and update the matrix



M


{\displaystyle M}
as we go. It's not so hard to believe that this algorithm will work relatively quickly if indeed the configuration of bounding boxes does not change significantly from one time step to the next.
In the case of deformable bodies such as cloth simulation, it may not be possible to use a more specific pairwise pruning algorithm as discussed below, and an n-body pruning algorithm is the best that can be done.
If an upper bound can be placed on the velocity of the physical bodies in a scene, then pairs of objects can be pruned based on their initial distance and the size of the time step.