Fredkin & Toffoli (1982) proposed the billiard-ball computer as part of their investigations into reversible computing. A billiard-ball computer consists of a system of synchronized particles (the billiard balls) moving in tracks and guided by a fixed set of obstacles. When the particles collide with each other or with the obstacles, they undergo an elastic collision much as real billiard balls would do. The input to the computer is encoded using the presence or absence of particles on certain input tracks, and its output is similarly encoded using the presence or absence of particles on output tracks. The tracks themselves may be envisioned as wires, and the particles as being Boolean signals transported on those wires. When a particle hits an obstacle, it reflects from it. This reflection may be interpreted as a change in direction of the wire the particle is following. Two particles on different tracks may collide, forming a logic gate at their collision point.
As Margolus (1984) showed, billiard-ball computers may be simulated using a two-state reversible block cellular automaton with the Margolus neighborhood. In this automaton's update rule, blocks with exactly one live cell rotate by 180°, blocks with two diagonally opposite live cells rotate by 90°, and all other blocks remain unchanged. These rules cause isolated live cells to behave like billiard balls, moving on diagonal trajectories. Connected groups of more than one live cell behave instead like the fixed obstacles of the billiard-ball computer. In an appendix, Margolus also showed that a three-state second-order cellular automaton using the two-dimensional Moore neighborhood could simulate billiard-ball computers.
One reason to study reversible universal models of computation such as the billiard-ball model is that they could theoretically lead to actual computer systems that consume very low quantities of energy. According to Landauer's principle, irreversible computational steps require a certain minimal amount of energy per step, but reversible steps can be performed with an amount of energy per step that is arbitrarily close to zero. However, in order to perform computation using less energy than Landauer's bound, it is not good enough for a cellular automaton to have a transition function that is globally reversible: what is required is that the local computation of the transition function also be done in a reversible way. For instance, reversible block cellular automata are always locally reversible: the behavior of each individual block involves the application of an invertible function with finitely many inputs and outputs. Toffoli & Margolus (1990) were the first to ask whether every reversible cellular automaton has a locally reversible update rule. Kari (1996) showed that for one- and two-dimensional automata the answer is positive, and Durand-Lose (2001) showed that any reversible cellular automaton could be simulated by a (possibly different) locally reversible cellular automaton. However, the question of whether every reversible transition function is locally reversible remains open for dimensions higher than two.